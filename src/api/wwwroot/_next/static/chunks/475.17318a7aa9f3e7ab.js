"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[475],{1475:(t,e,a)=>{a.d(e,{createAssistant:()=>i,createConfluenceDataSource:()=>b,createDataSources:()=>y,createFAQDataSource:()=>w,createGitHubDataSource:()=>T,deleteAssistant:()=>u,f4:()=>U,getAssistant:()=>o,sU:()=>c,yu:()=>E,getDataSources:()=>p,Zi:()=>l,updateAssistant:()=>d});let s=a(9509).env.NEXT_PUBLIC_API_URL||"";class r{async getAll(){let t=await fetch("".concat(this.baseUrl,"/assistants"));if(!t.ok)throw Error("Failed to fetch assistants: ".concat(t.statusText));return t.json()}async getById(t){let e=await fetch("".concat(this.baseUrl,"/assistants/").concat(t));if(!e.ok){if(404===e.status)return null;throw Error("Failed to fetch assistant: ".concat(e.statusText))}return e.json()}async create(t){let e=await fetch("".concat(this.baseUrl,"/assistants"),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw Error("Failed to create assistant: ".concat(e.statusText));return e.json()}async query(t,e){let a=await fetch("".concat(this.baseUrl,"/assistants/").concat(t),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!a.ok)throw Error("Failed to query assistant: ".concat(a.statusText));return a.json()}async delete(t){let e=await fetch("".concat(this.baseUrl,"/assistants/").concat(t),{method:"DELETE"});if(!e.ok)throw Error("Failed to delete assistant: ".concat(e.statusText))}async update(t,e){let a=await fetch("".concat(this.baseUrl,"/assistants/").concat(t),{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!a.ok)throw Error("Failed to update assistant: ".concat(a.statusText))}constructor(t=s){this.baseUrl=t}}let n=new r,c=()=>n.getAll(),o=t=>n.getById(t),i=t=>n.create(t),l=(t,e)=>n.query(t,e),u=t=>n.delete(t),d=(t,e)=>n.update(t,e);class h{async getAll(){let t=await fetch("".concat(this.baseUrl,"/datasources"));if(!t.ok)throw Error("Failed to fetch data sources: ".concat(t.statusText));return t.json()}async getById(t){return(await this.getAll()).find(e=>e.id===t)||null}async create(t,e){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=new FormData;t.forEach(t=>{s.append("files",t)}),s.append("name",e);let r=new URLSearchParams({type:"file",useQA:a.toString()}),n=await fetch("".concat(this.baseUrl,"/datasources?").concat(r),{method:"POST",body:s});if(!n.ok)throw Error("Failed to create data sources: ".concat(n.statusText));return n.json()}async createFAQ(t,e){let a=new FormData;t.forEach(t=>{a.append("files",t)}),a.append("name",e);let s=await fetch("".concat(this.baseUrl,"/datasources?type=faq"),{method:"POST",body:a});if(!s.ok)throw Error("Failed to create FAQ data sources: ".concat(s.statusText));return s.json()}async createConfluence(t){let e=new FormData;e.append("name",t.name),e.append("url",t.serverUrl),e.append("token",t.personalToken),e.append("parentPageId",t.parentUrl);let a=await fetch("".concat(this.baseUrl,"/datasources?type=confluence"),{method:"POST",body:e});if(!a.ok)throw Error("Failed to create Confluence data source: ".concat(a.statusText));return a.json()}async createGitHub(t){let e=new FormData;e.append("name",t.name),e.append("url",t.repositoryUrl),t.accessToken&&e.append("token",t.accessToken);let a=await fetch("".concat(this.baseUrl,"/datasources?type=github"),{method:"POST",body:e});if(!a.ok)throw Error("Failed to create GitHub data source: ".concat(a.statusText));return a.json()}async delete(t){let e=await fetch("".concat(this.baseUrl,"/datasources/").concat(t),{method:"DELETE"});if(!e.ok)throw Error("Failed to delete data source: ".concat(e.statusText))}constructor(t=s){this.baseUrl=t}}let f=new h,p=()=>f.getAll(),y=function(t,e){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return f.create(t,e,a)},w=(t,e)=>f.createFAQ(t,e),b=t=>f.createConfluence(t),T=t=>f.createGitHub(t),U=t=>f.delete(t),E=t=>{switch(t){case 0:return"Stream";case 1:return"File";case 2:return"GitHub";case 3:return"URL";case 4:return"Sitemap";case 5:return"Confluence";default:return"Unknown"}}}}]);